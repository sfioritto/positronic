import React from 'react';
import { render } from 'ink';
import { scanLocalResources, apiFetch } from './helpers.js';
import * as fs from 'fs';
import * as path from 'path';
import { type ResourceEntry } from '@positronic/core';
import { ResourceList } from '../components/resource-list.js';
import { ResourceSync } from '../components/resource-sync.js';
import { ResourceDelete } from '../components/resource-delete.js';
import { ErrorComponent } from '../components/error.js';

// Extend ResourceEntry to add fields returned by the API
interface ApiResourceEntry extends ResourceEntry {
  size: number;
  lastModified: string;
}

interface ResourcesListResponse {
  resources: ApiResourceEntry[];
  truncated: boolean;
  count: number;
}

/**
 * Check if a string is a valid JavaScript identifier
 */
function isValidJSIdentifier(name: string): boolean {
  // Must start with letter, underscore, or dollar sign
  // Can contain letters, digits, underscores, dollar signs
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name);
}

// TypeScript AST-like structures for cleaner generation
interface TypeProperty {
  name: string;
  type: string | TypeObject;
}

interface TypeObject {
  properties: TypeProperty[];
}

// Internal structure for building resource tree
interface ResourceNode {
  type?: 'text' | 'binary';
  fullName?: string; // Store the full filename for resources
  children?: Record<string, ResourceNode>;
}

/**
 * Build TypeScript structure from resource tree
 */
function buildTypeStructure(node: ResourceNode): TypeProperty[] {
  if (!node.children) return [];

  const properties: TypeProperty[] = [];
  const processedNames = new Set<string>();

  for (const [name, child] of Object.entries(node.children)) {
    if (processedNames.has(name)) continue;

    if (child.type) {
      // File resource
      const resourceType =
        child.type === 'text' ? 'TextResource' : 'BinaryResource';
      properties.push({ name, type: resourceType });
      processedNames.add(name);

      if (child.fullName) {
        processedNames.add(child.fullName);
      }
    } else if (child.children) {
      // Directory with nested resources
      const nestedProps = buildTypeStructure(child);
      if (nestedProps.length > 0) {
        properties.push({
          name,
          type: { properties: nestedProps },
        });
        processedNames.add(name);
      }
    }
  }

  return properties;
}

/**
 * Render TypeScript from structure
 */
function renderTypeScript(
  properties: TypeProperty[],
  indent: string = '    '
): string {
  return properties
    .map((prop) => {
      if (typeof prop.type === 'string') {
        return `${indent}${prop.name}: ${prop.type};`;
      } else {
        const nestedContent = renderTypeScript(
          prop.type.properties,
          indent + '  '
        );
        return `${indent}${prop.name}: {\n${nestedContent}\n${indent}};`;
      }
    })
    .join('\n');
}

/**
 * Generate TypeScript declarations for resources
 */
function generateResourceTypes(resources: ApiResourceEntry[]): string {
  const root: ResourceNode = { children: {} };

  // Build the tree structure
  for (const resource of resources) {
    const parts = resource.key.split('/');
    let current = root;

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLeaf = i === parts.length - 1;

      if (!current.children) {
        current.children = {};
      }

      if (isLeaf) {
        const resourceNode: ResourceNode = {
          type: resource.type,
          fullName: part,
        };

        if (isValidJSIdentifier(part)) {
          current.children[part] = resourceNode;
        }

        const withoutExt = part.replace(/\.[^/.]+$/, '');
        if (withoutExt !== part && isValidJSIdentifier(withoutExt)) {
          if (!current.children[withoutExt]) {
            current.children[withoutExt] = resourceNode;
          }
        }
      } else {
        if (isValidJSIdentifier(part)) {
          if (!current.children[part]) {
            current.children[part] = { children: {} };
          }
          current = current.children[part];
        } else {
          break;
        }
      }
    }
  }

  const typeStructure = buildTypeStructure(root);
  const interfaceContent = renderTypeScript(typeStructure);

  return `// Generated by Positronic CLI
// This file provides TypeScript types for your resources

declare module '@positronic/core' {
  interface TextResource {
    load(): Promise<string>;
    loadText(): Promise<string>;
    loadBinary(): never;
  }

  interface BinaryResource {
    load(): Promise<Buffer>;
    loadText(): never;
    loadBinary(): Promise<Buffer>;
  }

  interface Resources {
    // Method signatures for loading resources by path
    loadText(path: string): Promise<string>;
    loadBinary(path: string): Promise<Buffer>;

    // Resource properties accessible via dot notation
${interfaceContent}
  }
}

export {}; // Make this a module
`;
}

export class ResourceCommand {
  constructor(
    private isLocalDevMode: boolean,
    private projectRootPath: string | null
  ) {}

  async list() {
    render(React.createElement(ResourceList));
  }

  async sync() {
    if (!this.isLocalDevMode || !this.projectRootPath) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Command Not Available',
            message:
              'sync command is only available in local development mode.',
            details: 'Navigate to your project directory to use this command.',
          },
        })
      );
      return;
    }

    // Check if resources directory exists, create if it doesn't
    const resourcesDir = path.join(this.projectRootPath, 'resources');
    if (!fs.existsSync(resourcesDir)) {
      fs.mkdirSync(resourcesDir, { recursive: true });
    }
    const localResources = scanLocalResources(resourcesDir);

    render(
      React.createElement(ResourceSync, {
        localResources,
        resourcesDir,
      })
    );
  }

  async types() {
    if (!this.isLocalDevMode || !this.projectRootPath) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Command Not Available',
            message:
              'types command is only available in local development mode.',
            details: 'Navigate to your project directory to use this command.',
          },
        })
      );
      return;
    }

    const typesFilePath = path.join(this.projectRootPath, 'resources.d.ts');

    try {
      // Fetch resources from the API
      const response = await apiFetch('/resources');

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `Failed to fetch resources: ${response.status} ${errorText}`
        );
      }

      const data = (await response.json()) as ResourcesListResponse;
      const typeDefinitions = generateResourceTypes(data.resources);

      fs.writeFileSync(typesFilePath, typeDefinitions, 'utf-8');

      // Use a simple success component for now
      console.log(
        `âœ… Generated resource types at ${path.relative(
          process.cwd(),
          typesFilePath
        )}`
      );
    } catch (error) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Type Generation Failed',
            message: 'Failed to generate resource types.',
            details: error instanceof Error ? error.message : String(error),
          },
        })
      );
    }
  }

  async delete(resourcePath: string) {
    if (!resourcePath) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Missing Resource Path',
            message: 'Please provide a resource path to delete.',
            details: 'Usage: positronic resource delete <path>',
          },
        })
      );
      return;
    }

    // The resourcePath should be relative to the resources directory
    const resourceKey = resourcePath;

    render(
      React.createElement(ResourceDelete, {
        resourceKey,
        resourcePath,
      })
    );
  }

  async clear() {
    if (!this.isLocalDevMode) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Command Not Available',
            message:
              'clear command is only available in local development mode.',
            details:
              'This command deletes all resources and should only be used during development.',
          },
        })
      );
      return;
    }

    // Import and render ResourceClear component (to be created)
    const { ResourceClear } = await import('../components/resource-clear.js');
    render(React.createElement(ResourceClear));
  }
}
