import React from 'react';
import { render } from 'ink';
import { scanLocalResources, apiFetch } from './helpers.js';
import * as fs from 'fs';
import * as path from 'path';
import { type ResourceEntry } from '@positronic/core';
import { ResourceList } from '../components/resource-list.js';
import { ResourceSync } from '../components/resource-sync.js';
import { ResourceDelete } from '../components/resource-delete.js';
import { ErrorComponent } from '../components/error.js';

// Extend ResourceEntry to add fields returned by the API
interface ApiResourceEntry extends ResourceEntry {
  size: number;
  lastModified: string;
}

interface ResourcesListResponse {
  resources: ApiResourceEntry[];
  truncated: boolean;
  count: number;
}

// Common text file extensions
const TEXT_EXTENSIONS = new Set([
  '.txt',
  '.md',
  '.json',
  '.js',
  '.ts',
  '.jsx',
  '.tsx',
  '.css',
  '.scss',
  '.sass',
  '.html',
  '.xml',
  '.yaml',
  '.yml',
  '.toml',
  '.ini',
  '.cfg',
  '.conf',
  '.sh',
  '.bash',
  '.zsh',
  '.fish',
  '.py',
  '.rb',
  '.php',
  '.java',
  '.c',
  '.cpp',
  '.h',
  '.hpp',
  '.rs',
  '.go',
  '.swift',
  '.kt',
  '.scala',
  '.r',
  '.sql',
  '.graphql',
  '.vue',
  '.svelte',
  '.csv',
  '.log',
  '.env',
  '.gitignore',
  '.dockerignore',
  '.editorconfig',
  '.prettierrc',
  '.eslintrc',
  '.babelrc',
]);

/**
 * Check if a string is a valid JavaScript identifier
 */
function isValidJSIdentifier(name: string): boolean {
  // Must start with letter, underscore, or dollar sign
  // Can contain letters, digits, underscores, dollar signs
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name);
}

/**
 * Generate TypeScript declarations for resources
 */
function generateResourceTypes(resources: ApiResourceEntry[]): string {
  // Build a nested structure from flat resource list
  interface ResourceNode {
    type?: 'text' | 'binary';
    fullName?: string; // Store the full filename for resources
    children?: Record<string, ResourceNode>;
  }

  const root: ResourceNode = { children: {} };
  // Build the tree structure
  for (const resource of resources) {
    const parts = resource.key.split('/');
    let current = root;

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLeaf = i === parts.length - 1;

      if (!current.children) {
        current.children = {};
      }

      if (isLeaf) {
        // This is a file - create the resource node
        const resourceNode = {
          type: resource.type,
          fullName: part,
        };

        // Add with full filename if it's a valid identifier
        if (isValidJSIdentifier(part)) {
          current.children[part] = resourceNode;
        }

        // Also add without extension if the base name is a valid identifier
        const withoutExt = part.replace(/\.[^/.]+$/, '');
        if (withoutExt !== part && isValidJSIdentifier(withoutExt)) {
          // Check if there's already something with this name
          if (!current.children[withoutExt]) {
            current.children[withoutExt] = resourceNode;
          }
          // If there's already something with this name, we skip to avoid ambiguity
        }
      } else {
        // This is a directory
        if (isValidJSIdentifier(part)) {
          if (!current.children[part]) {
            current.children[part] = { children: {} };
          }
          current = current.children[part];
        } else {
          // Skip invalid directory names - they won't be accessible
          break;
        }
      }
    }
  }

  // Generate the TypeScript interface
  function generateInterface(
    node: ResourceNode,
    indent: string = '    '
  ): string {
    let result = '';

    if (!node.children) {
      return result;
    }

    const entries = Object.entries(node.children);
    const processedNames = new Set<string>();

    for (const [name, child] of entries) {
      // Skip if we've already processed this (e.g., handled by extension-less version)
      if (processedNames.has(name)) continue;

      if (child.type) {
        // This is a file resource
        const resourceType =
          child.type === 'text' ? 'TextResource' : 'BinaryResource';
        result += `${indent}${name}: ${resourceType};\n`;
        processedNames.add(name);

        // If this has a full name, mark it as processed too
        if (child.fullName) {
          processedNames.add(child.fullName);
        }
      } else if (child.children) {
        // This is a directory
        result += `${indent}${name}: {\n`;
        result += generateInterface(child, indent + '  ');
        result += `${indent}};\n`;
        processedNames.add(name);
      }
    }

    return result;
  }

  const interfaceContent = generateInterface(root);

  return `// Generated by Positronic CLI
// This file provides TypeScript types for your resources

declare module '@positronic/core' {
  interface TextResource {
    load(): Promise<string>;
    loadText(): Promise<string>;
    loadBinary(): never;
  }

  interface BinaryResource {
    load(): Promise<Buffer>;
    loadText(): never;
    loadBinary(): Promise<Buffer>;
  }

  interface Resources {
    // Method signatures for loading resources by path
    loadText(path: string): Promise<string>;
    loadBinary(path: string): Promise<Buffer>;

    // Resource properties accessible via dot notation
${interfaceContent}  }
}

export {}; // Make this a module
`;
}

export class ResourceCommand {
  constructor(
    private isLocalDevMode: boolean,
    private projectRootPath: string | null
  ) {}

  async list() {
    render(React.createElement(ResourceList));
  }

  async sync() {
    if (!this.isLocalDevMode || !this.projectRootPath) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Command Not Available',
            message:
              'sync command is only available in local development mode.',
            details: 'Navigate to your project directory to use this command.',
          },
        })
      );
      return;
    }

    // Check if resources directory exists, create if it doesn't
    const resourcesDir = path.join(this.projectRootPath, 'resources');
    if (!fs.existsSync(resourcesDir)) {
      fs.mkdirSync(resourcesDir, { recursive: true });
    }
    const localResources = scanLocalResources(resourcesDir, TEXT_EXTENSIONS);

    render(
      React.createElement(ResourceSync, {
        localResources,
        resourcesDir,
        textExtensions: TEXT_EXTENSIONS,
      })
    );
  }

  async types() {
    if (!this.isLocalDevMode || !this.projectRootPath) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Command Not Available',
            message:
              'types command is only available in local development mode.',
            details: 'Navigate to your project directory to use this command.',
          },
        })
      );
      return;
    }

    const typesFilePath = path.join(this.projectRootPath, 'resources.d.ts');

    try {
      // Fetch resources from the API
      const response = await apiFetch('/resources');

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `Failed to fetch resources: ${response.status} ${errorText}`
        );
      }

      const data = (await response.json()) as ResourcesListResponse;
      const typeDefinitions = generateResourceTypes(data.resources);

      fs.writeFileSync(typesFilePath, typeDefinitions, 'utf-8');

      // Use a simple success component for now
      console.log(
        `âœ… Generated resource types at ${path.relative(
          process.cwd(),
          typesFilePath
        )}`
      );
    } catch (error) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Type Generation Failed',
            message: 'Failed to generate resource types.',
            details: error instanceof Error ? error.message : String(error),
          },
        })
      );
    }
  }

  async delete(resourcePath: string) {
    if (!resourcePath) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Missing Resource Path',
            message: 'Please provide a resource path to delete.',
            details: 'Usage: positronic resource delete <path>',
          },
        })
      );
      return;
    }

    // The resourcePath should be relative to the resources directory
    const resourceKey = resourcePath;

    render(
      React.createElement(ResourceDelete, {
        resourceKey,
        resourcePath,
      })
    );
  }

  async clear() {
    if (!this.isLocalDevMode) {
      render(
        React.createElement(ErrorComponent, {
          error: {
            title: 'Command Not Available',
            message:
              'clear command is only available in local development mode.',
            details:
              'This command deletes all resources and should only be used during development.',
          },
        })
      );
      return;
    }

    // Import and render ResourceClear component (to be created)
    const { ResourceClear } = await import('../components/resource-clear.js');
    render(React.createElement(ResourceClear));
  }
}
